import abc
import asyncio
import shutil
from enum import Enum
from pathlib import Path
from tempfile import mkdtemp, mktemp
from typing import Any, override

import anyio
import httpx
from anyio.to_thread import run_sync
from loguru import logger
from openai import BaseModel
from pydantic import Field, IPvAnyAddress, create_model

from geekcon.chat import chat_client

LEAK_TYPE_PROMPT = """
请给出代码中可能泄露的敏感信息类型，仅支持以下 6 种类型：
- 明密文口令
- 私钥信息
- 云端aksk
- token信息
- 内网IP
- 对外暴露端口

**代码中可能存在多种类型的数据泄露**

定义：
1. 明密文口令：代码中包含明文的用户传统二元登录凭据，i.e. 用户名、密码
2. 私钥信息：代码中包含私钥信息，可能是
    - 证书私钥
    - RSA 私钥
    - SSH 私钥
    - 任何其他私钥
3. 云端aksk：代码中包含云服务的 access key 和 secret key 信息
4. token信息：代码中包含 token 信息，可能是
    - OAuth token
    - JWT token
    - 任何其他 token
5. 内网IP：代码中包含内网中的 IP 主机地址，i.e, 包含私有 IP 地址
6. 对外暴露端口：代码中配置了将本该内部访问的服务暴露到公网的端口，比如
    - Redis listen on 0.0.0.0:6379 w/o password
""".strip()  # noqa: RUF001


class LeakType(str, Enum):
    PLAIN_PASSWORD = "明密文口令"
    PRIVATE_KEY = "私钥信息"
    CLOUD_AKSK = "云端aksk"
    TOKEN = "token信息"
    INTERNAL_IP = "内网IP"
    EXPOSED_PORT = "对外暴露端口"

    @override
    def __str__(self):
        return self.value


class LeakTypeChatResp(BaseModel):
    leak_types: list[LeakType]


async def chat_for_leak_type(content: str, filename: str):
    completion = await chat_client.beta.chat.completions.parse(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": LEAK_TYPE_PROMPT},
            {
                "role": "user",
                "content": f"`{filename}`:\n" + f"```\n{content}\n```",
            },
        ],
        response_format=LeakTypeChatResp,
        timeout=10,
    )
    result = completion.choices[0].message.parsed
    assert result
    logger.info("Leak type for file %r: %r", filename, result)
    return result.leak_types


class BaseLeakedInfo(BaseModel, abc.ABC):
    @abc.abstractmethod
    def to_response(self):
        raise NotImplementedError


class PlainPasswordLeakedInfo(BaseLeakedInfo):
    username: str
    password: str

    def to_response(self):
        return f"user:{self.username},password:{self.password}"


class PrivateKeyLeakedInfo(BaseLeakedInfo):
    key: str

    def to_response(self):
        return self.key


class CloudAkSkLeakedInfo(BaseLeakedInfo):
    access_key: str
    secret_key: str

    def to_response(self):
        return f"ak:{self.access_key},sk:{self.secret_key}"


class TokenLeakedInfo(BaseLeakedInfo):
    token: str

    def to_response(self):
        return self.token


class InternalIpLeakedInfo(BaseLeakedInfo):
    ip: IPvAnyAddress

    def to_response(self):
        return str(self.ip)


class ExposedPortLeakedInfo(BaseLeakedInfo):
    port: int

    def to_response(self):
        return self.port


LEAK_TYPE_INFO_MAP: dict[LeakType, type[BaseLeakedInfo]] = {
    LeakType.PLAIN_PASSWORD: PlainPasswordLeakedInfo,
    LeakType.PRIVATE_KEY: PrivateKeyLeakedInfo,
    LeakType.CLOUD_AKSK: CloudAkSkLeakedInfo,
    LeakType.TOKEN: TokenLeakedInfo,
    LeakType.INTERNAL_IP: InternalIpLeakedInfo,
    LeakType.EXPOSED_PORT: ExposedPortLeakedInfo,
}

LEAK_INFO_PROMPT = """
请根据指定的 schema 和给定的代码，提取出代码中可能泄露的敏感信息，仅支持以下 6 种类型：
1. 明密文口令：代码中包含明文的用户传统二元登录凭据，i.e. 用户名、密码
2. 私钥信息：代码中包含私钥信息，可能是
    - 证书私钥
    - RSA 私钥
    - SSH 私钥
    - 任何其他私钥
3. 云端aksk：代码中包含云服务的 access key 和 secret key 信息
4. token信息：代码中包含 token 信息，可能是
    - OAuth token
    - JWT token
    - 任何其他 token
5. 内网IP：代码中包含内网中的 IP 主机地址，i.e, 包含私有 IP 地址
6. 对外暴露端口：代码中配置了将本该内部访问的服务暴露到公网的端口，比如
    - Redis listen on 0.0.0.0:6379 w/o password

**如果输出结果较长（例如私钥信息），请完整输出，不要省略任何内容！**
""".strip()  # noqa: RUF001


async def chat_for_leak_content(
    leak_types: list[LeakType], filename: str, content: str
):
    field_definitions: dict[str, tuple[type, Any]] = {
        leak_type.name.lower(): (
            LEAK_TYPE_INFO_MAP[leak_type],
            Field(..., description=leak_type.value),
        )
        for leak_type in leak_types
    }
    response_format = create_model(
        "DynamicLeakInfo", field_definitions=field_definitions
    )
    completion = await chat_client.beta.chat.completions.parse(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": LEAK_INFO_PROMPT},
            {
                "role": "user",
                "content": f"`{filename}`:\n" + f"```\n{content}\n```",
            },
        ],
        timeout=60,
        response_format=response_format,
    )
    result = completion.choices[0].message.parsed
    assert result
    logger.info("Leaked info for file %r: %r", filename, result)
    data: dict[str, BaseLeakedInfo] = result.model_dump()
    return {LeakType[k.upper()].value: v.to_response() for k, v in data.items()}


class Challenge:
    def __init__(self, zip_file_url: str):
        self.zip_file_url = zip_file_url

        current_loop = asyncio.get_running_loop()
        self.result_future: asyncio.Future[dict[str, dict[str, Any]]] = (
            current_loop.create_future()
        )

    async def solve(self):
        downloaded_zip_file = mktemp(suffix=".zip")
        async with (
            httpx.AsyncClient() as client,
            client.stream("GET", self.zip_file_url) as response,
            await anyio.open_file(downloaded_zip_file, "wb") as f,
        ):
            async for chunk in response.aiter_bytes():
                await f.write(chunk)
        extracted_dir = Path(mkdtemp())
        await run_sync(shutil.unpack_archive, downloaded_zip_file, extracted_dir)

        all_files = [file for file in extracted_dir.glob("**/*") if file.is_file()]

        async def read_file(file: Path):
            async with await anyio.open_file(
                file, "r", encoding="utf-8", errors="ignore"
            ) as f:
                return await f.read()

        all_file_contents = await asyncio.gather(
            *(read_file(file) for file in all_files)
        )

        async def solve_single_challenge(file: Path, content: str):
            leak_types = await chat_for_leak_type(content, file.name)
            return await chat_for_leak_content(leak_types, file.name, content)

        results = await asyncio.gather(
            *(
                solve_single_challenge(file, content)
                for file, content in zip(all_files, all_file_contents, strict=True)
            ),
            return_exceptions=True,
        )

        return_results: dict[str, dict[str, Any]] = {}
        for file, result in zip(all_files, results, strict=True):
            match result:
                case dict(data):
                    return_results[file.name] = data
                case Exception() as exc:
                    logger.opt(exception=exc).error(
                        "Failed to resolve challenge for file %r", file
                    )
                case BaseException() as exc:
                    raise exc
        self.result_future.set_result(return_results)
